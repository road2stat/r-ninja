# 自动化报告

人类和计算机有各自擅长的东西，人擅长下指令，计算机擅长执行指令，而且对计算机来说，一个任务做一遍或是做一百遍可能只有时间上的区别，但一个人要是同一个任务重复做一百遍可能就抓狂了，而且容易出错。先跑个题，我想起来有个[短片](http://v.youku.com/v_show/id_XMjQyNjU3NjA0.html)叫《What is that》（那是什么），讲的是一对父子和一只麻雀的故事，网上一[搜](http://www.dfg.cn/gb/jtjy/qzp/56-ai.htm)就可以找到；当然，它的主题并不是关于人不能忍受重复劳动，我只是跑题而已。

另一方面，人还有最大的一个特征就是懒惰；懒没什么错，看怎么个懒法。有人纯粹是混日子的懒，有人是为了更高效率工作而走捷径。用R做自动化报告就是为了提高效率和保证结果可重复。

## 历史

在R的世界里，凡是提到自动化报告，很多人就会想到Sweave，它已经诞生十几年了。它的主要设计思想来自于文学化编程（Literate Programming），这是Knuth大神提出来的一种编程范式，它与传统的结构化编程不同。结构化编程就是写那些循环（for/while）、选择分支（if else）、函数模块之类的代码，让计算机去按设定好的程序结构去执行，而文学化编程则是把代码嵌入所谓的文学作品中，之所以说所谓的，是因为这里的文学不一定真的是那种常规意义下的文学，只是指人类语言而已，相对计算机代码而言。文学化编程的思想很简单：代码和正文混和在同一个文档中，编译的时候既可以把代码抽出来运行得到结果，也可以把正文抽出来形成软件文档。最初它是为了写软件而设计的，这种设计方式的优势显而易见：代码和文档在一起，方便互相更新和照应。比如修改了代码之后可以很快也更新相应的文档段落，而不必像传统方式那样，从源代码文件跳到文档文件中去更新（人的记忆不可靠，这事儿经常忘记，造成代码和文档不一致）。

要使用文学化编程，必须得有一些设定的规则来标记哪些是代码，哪些是正文，否则这事儿没法进行。最早的语法是这样：用`<<>>=`来标记代码的开始，用`@`标记正文的开始，凡是遇到这两类符号，也就意味着要换频道了，下文要标记为代码或正文。例如，

```
@
hello, I will do 1 + 2 next:

<<foo>>=
1 + 2
@

OK, I'm done now.
```

这一块文字中包含两段正文和一段代码。编译它的时候，计算机根据前面的规则就知道`<<>>=`下面的是可以运算的代码，而`@`下面是正文，不能当作代码运行。这就是文学化编程的基本思想，它可以很容易移植到自动化报告中来，下面我们再详细说里面的细节问题。Sweave借用了这个思想，把R代码嵌入报告中，编译报告的时候R代码被执行，源文档中的R代码在输出的时候被替换为相应的运行结果，这些结果和原来的报告正文混合起来就形成了一篇有结果的报告。这样，我们只需要维护包含源代码的源文档，让结果文档自动生成，而不要手工运行代码并复制粘贴结果到文档里，这样做既累人又容易出错。记住，只有源代码是可以信赖的。注意我并不是说它的结果一定是对的，或者源代码一定是对的，代码当然可能是错的，但源代码要是错了我们可以检查出来，而要是人工操作哪里出了岔子就很难查错，比如你本来应该点这个按钮，结果你当时点了另一个，如果没有完整的屏幕录像，恐怕追溯结果的来源时就比较困难了。源代码通常是文本文件，可以放入版本控制如GIT或SVN，记录完整的修改历史。附带说一句，版本控制（Version Control）工具是忍者必备工具，后面会讲，你要是不会这东西的话，别跟别人说你看过这本书。

文学化编程最早和TeX结合在一起，因为文档用TeX写漂亮嘛，但这事儿跟Knuth肯定也脱不了关系，因为这位大神就是TeX系统的作者，这是计算机世界的佳话（老人家当年不满意出版社的排版质量，一举自己写了一套高质量排版系统，并写支票奖励发现缺陷的人，奖金都是16进制的1美元，而且金额随缺陷数目递增，我跑远了，各位要是没听说过这些轶事自己搜吧）。于是，计算机代码用某种语言写，比如C语言，而文档用TeX写；要源代码可以抽代码，要文档可以抽文档，皆大欢喜。

Sweave的诞生也跟TeX绑在一起，这就为它后来的应用埋下了悲剧的种子，因为TeX不是一般人能精通的。我用了八年LaTeX，自认为对它还比较熟，但仅限于使用，要是让我去读那些LaTeX包的源代码，我几乎读不懂，太庞大太复杂了。Sweave的设计里处处是硬编码，所以它很难扩展，一直以来只能被框在TeX世界里，曲高和寡。尽管Knuth大人弄出来这样一个牛轰轰的想法，Sweave基本上也把它实现了，但这东西太难推广了。初学者编译TeX文档难免遇到一堆看不懂的错误，进而气馁，最后疏远它。我用了几年Sweave，在这方面也做了很多工作，想让它变得易用一些，比如开发了LyX模块，让用户可以在LyX里面点按钮就可以直接编译得到PDF文件。即便如此，Sweave的深层问题无法解决，很多简单的问题我等了又等（比如设置图片在TeX文档中的宽度），一直没有等到答案，屡屡想重写它，但忍者的基本素质就是忍，没事儿不要重新发明一个东西。2011年底我终于忍不住了，操起键盘重写了一个新包，叫**knitr**。

## knitr包

你要是没学习过Sweave，最好别去花那时间，可以直接跳入**knitr**世界，它兼容Sweave并提供了无限的扩展性，这本书就是用它基于Markdown写的。先举一个hello world例子吧：



```r
1 + 2
```



```
## [1] 3
```



```r
dnorm(0)  # 标准正态分布在0处的密度值
```



```
## [1] 0.3989
```



```r
summary(lm(dist ~ speed, data = cars))  # 一个回归
```



```
## 
## Call:
## lm(formula = dist ~ speed, data = cars)
## 
## Residuals:
##    Min     1Q Median     3Q    Max 
## -29.07  -9.53  -2.27   9.21  43.20 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(>|t|)    
## (Intercept)  -17.579      6.758   -2.60    0.012 *  
## speed          3.932      0.416    9.46  1.5e-12 ***
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 
## 
## Residual standard error: 15.4 on 48 degrees of freedom
## Multiple R-squared: 0.651,	Adjusted R-squared: 0.644 
## F-statistic: 89.6 on 1 and 48 DF,  p-value: 1.49e-12 
## 
```




上面你看到的是R的输出，其实它的源文件只有5行，1行标记代码开始，3行R代码，1行标记正文开始。

## 编辑器

### LyX

### RStudio

## 其它包

